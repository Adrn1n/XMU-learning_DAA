/*
旅游计划2

描述

Z王国有若干个城市(编号从1开始),每两个城市之间都有一条道路.

由于Z王国的特殊政策,每个城市只允许游客访问一次.

请你帮助小H规划一条旅行路线,使得小H可以访问所有城市,并且每个城市只访问一次

由于城市数量过多,小H放宽了要求,最终的路径长度不需要最短,只要优于小H的可接受值即可

然而我们并不知道小H的可接受值是多少,因此我们能做的就是尽可能缩短路径长度

输入

第一行是一个样例编号t,没有实际作用,只需要原封不动输出即可

第二行是一个整数n(1<=n<=50),表示城市的个数

接下来是一个n*n的对称矩阵,元素dis[i,j]表示i城市与j城市间道路的长度(1<=dis[i,j]<=10000,dis[i,i]=0,dis[i,j]=dis[j,i])

输出

第一行输出样例编号t

第二行输出n个空格分开的整数,代表你的尽可能短的路径

输入样例 1

0
16
0 12 6 18 9 7 2 15 2 10 2 3 14 3 8 14
12 0 7 17 13 15 10 21 10 5 24 22 13 23 22 20
6 7 0 22 11 21 13 22 24 21 25 17 16 3 3 23
18 17 22 0 20 25 12 4 4 1 16 11 3 7 7 21
9 13 11 20 0 19 20 15 23 19 19 1 4 7 24 1
7 15 21 25 19 0 4 6 13 21 25 16 12 21 12 23
2 10 13 12 20 4 0 17 8 8 16 9 21 17 2 21
15 21 22 4 15 6 17 0 8 6 21 11 12 19 23 5
2 10 24 4 23 13 8 8 0 7 14 19 20 24 20 4
10 5 21 1 19 21 8 6 7 0 6 25 18 2 2 4
2 24 25 16 19 25 16 21 14 6 0 10 8 1 25 22
3 22 17 11 1 16 9 11 19 25 10 0 3 22 2 12
14 13 16 3 4 12 21 12 20 18 8 3 0 18 20 8
3 23 3 7 7 21 17 19 24 2 1 22 18 0 3 25
8 22 3 7 24 12 2 23 20 2 25 2 20 3 0 19
14 20 23 21 1 23 21 5 4 4 22 12 8 25 19 0

输出样例 1

0
2 10 14 11 1 7 6 8 13 4 9 16 5 12 15 3

来源

xmu

温馨提示

实在搞不定的话，你可以 点此下载测试数据 (./problem_5405_test_cases.zip)
*/

#include <iostream>

using namespace std;

int main()
{
    cout << "Hello world!" << endl;
    return 0;
}
